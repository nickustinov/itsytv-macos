// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ContentItemMetadata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct MRP_ContentItemMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var subtitle: String {
    get {return _storage._subtitle ?? String()}
    set {_uniqueStorage()._subtitle = newValue}
  }
  /// Returns true if `subtitle` has been explicitly set.
  var hasSubtitle: Bool {return _storage._subtitle != nil}
  /// Clears the value of `subtitle`. Subsequent reads from it will return its default value.
  mutating func clearSubtitle() {_uniqueStorage()._subtitle = nil}

  var isContainer: Bool {
    get {return _storage._isContainer ?? false}
    set {_uniqueStorage()._isContainer = newValue}
  }
  /// Returns true if `isContainer` has been explicitly set.
  var hasIsContainer: Bool {return _storage._isContainer != nil}
  /// Clears the value of `isContainer`. Subsequent reads from it will return its default value.
  mutating func clearIsContainer() {_uniqueStorage()._isContainer = nil}

  var isPlayable: Bool {
    get {return _storage._isPlayable ?? false}
    set {_uniqueStorage()._isPlayable = newValue}
  }
  /// Returns true if `isPlayable` has been explicitly set.
  var hasIsPlayable: Bool {return _storage._isPlayable != nil}
  /// Clears the value of `isPlayable`. Subsequent reads from it will return its default value.
  mutating func clearIsPlayable() {_uniqueStorage()._isPlayable = nil}

  var playbackProgress: Float {
    get {return _storage._playbackProgress ?? 0}
    set {_uniqueStorage()._playbackProgress = newValue}
  }
  /// Returns true if `playbackProgress` has been explicitly set.
  var hasPlaybackProgress: Bool {return _storage._playbackProgress != nil}
  /// Clears the value of `playbackProgress`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackProgress() {_uniqueStorage()._playbackProgress = nil}

  var albumName: String {
    get {return _storage._albumName ?? String()}
    set {_uniqueStorage()._albumName = newValue}
  }
  /// Returns true if `albumName` has been explicitly set.
  var hasAlbumName: Bool {return _storage._albumName != nil}
  /// Clears the value of `albumName`. Subsequent reads from it will return its default value.
  mutating func clearAlbumName() {_uniqueStorage()._albumName = nil}

  var trackArtistName: String {
    get {return _storage._trackArtistName ?? String()}
    set {_uniqueStorage()._trackArtistName = newValue}
  }
  /// Returns true if `trackArtistName` has been explicitly set.
  var hasTrackArtistName: Bool {return _storage._trackArtistName != nil}
  /// Clears the value of `trackArtistName`. Subsequent reads from it will return its default value.
  mutating func clearTrackArtistName() {_uniqueStorage()._trackArtistName = nil}

  var albumArtistName: String {
    get {return _storage._albumArtistName ?? String()}
    set {_uniqueStorage()._albumArtistName = newValue}
  }
  /// Returns true if `albumArtistName` has been explicitly set.
  var hasAlbumArtistName: Bool {return _storage._albumArtistName != nil}
  /// Clears the value of `albumArtistName`. Subsequent reads from it will return its default value.
  mutating func clearAlbumArtistName() {_uniqueStorage()._albumArtistName = nil}

  var duration: Double {
    get {return _storage._duration ?? 0}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {_uniqueStorage()._duration = nil}

  var localizedContentRating: String {
    get {return _storage._localizedContentRating ?? String()}
    set {_uniqueStorage()._localizedContentRating = newValue}
  }
  /// Returns true if `localizedContentRating` has been explicitly set.
  var hasLocalizedContentRating: Bool {return _storage._localizedContentRating != nil}
  /// Clears the value of `localizedContentRating`. Subsequent reads from it will return its default value.
  mutating func clearLocalizedContentRating() {_uniqueStorage()._localizedContentRating = nil}

  var artworkAvailable: Bool {
    get {return _storage._artworkAvailable ?? false}
    set {_uniqueStorage()._artworkAvailable = newValue}
  }
  /// Returns true if `artworkAvailable` has been explicitly set.
  var hasArtworkAvailable: Bool {return _storage._artworkAvailable != nil}
  /// Clears the value of `artworkAvailable`. Subsequent reads from it will return its default value.
  mutating func clearArtworkAvailable() {_uniqueStorage()._artworkAvailable = nil}

  var collectionIdentifier: String {
    get {return _storage._collectionIdentifier ?? String()}
    set {_uniqueStorage()._collectionIdentifier = newValue}
  }
  /// Returns true if `collectionIdentifier` has been explicitly set.
  var hasCollectionIdentifier: Bool {return _storage._collectionIdentifier != nil}
  /// Clears the value of `collectionIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearCollectionIdentifier() {_uniqueStorage()._collectionIdentifier = nil}

  var artworkMimetype: String {
    get {return _storage._artworkMimetype ?? String()}
    set {_uniqueStorage()._artworkMimetype = newValue}
  }
  /// Returns true if `artworkMimetype` has been explicitly set.
  var hasArtworkMimetype: Bool {return _storage._artworkMimetype != nil}
  /// Clears the value of `artworkMimetype`. Subsequent reads from it will return its default value.
  mutating func clearArtworkMimetype() {_uniqueStorage()._artworkMimetype = nil}

  var elapsedTime: Double {
    get {return _storage._elapsedTime ?? 0}
    set {_uniqueStorage()._elapsedTime = newValue}
  }
  /// Returns true if `elapsedTime` has been explicitly set.
  var hasElapsedTime: Bool {return _storage._elapsedTime != nil}
  /// Clears the value of `elapsedTime`. Subsequent reads from it will return its default value.
  mutating func clearElapsedTime() {_uniqueStorage()._elapsedTime = nil}

  var playbackRate: Float {
    get {return _storage._playbackRate ?? 0}
    set {_uniqueStorage()._playbackRate = newValue}
  }
  /// Returns true if `playbackRate` has been explicitly set.
  var hasPlaybackRate: Bool {return _storage._playbackRate != nil}
  /// Clears the value of `playbackRate`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackRate() {_uniqueStorage()._playbackRate = nil}

  var contentIdentifier: String {
    get {return _storage._contentIdentifier ?? String()}
    set {_uniqueStorage()._contentIdentifier = newValue}
  }
  /// Returns true if `contentIdentifier` has been explicitly set.
  var hasContentIdentifier: Bool {return _storage._contentIdentifier != nil}
  /// Clears the value of `contentIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearContentIdentifier() {_uniqueStorage()._contentIdentifier = nil}

  var elapsedTimeTimestamp: Double {
    get {return _storage._elapsedTimeTimestamp ?? 0}
    set {_uniqueStorage()._elapsedTimeTimestamp = newValue}
  }
  /// Returns true if `elapsedTimeTimestamp` has been explicitly set.
  var hasElapsedTimeTimestamp: Bool {return _storage._elapsedTimeTimestamp != nil}
  /// Clears the value of `elapsedTimeTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearElapsedTimeTimestamp() {_uniqueStorage()._elapsedTimeTimestamp = nil}

  var artworkIdentifier: String {
    get {return _storage._artworkIdentifier ?? String()}
    set {_uniqueStorage()._artworkIdentifier = newValue}
  }
  /// Returns true if `artworkIdentifier` has been explicitly set.
  var hasArtworkIdentifier: Bool {return _storage._artworkIdentifier != nil}
  /// Clears the value of `artworkIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearArtworkIdentifier() {_uniqueStorage()._artworkIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MRP_ContentItemMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ContentItemMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}subtitle\0\u{1}isContainer\0\u{1}isPlayable\0\u{1}playbackProgress\0\u{1}albumName\0\u{1}trackArtistName\0\u{1}albumArtistName\0\u{2}\u{6}duration\0\u{1}localizedContentRating\0\u{2}\u{4}artworkAvailable\0\u{2}\u{9}collectionIdentifier\0\u{2}\u{3}artworkMIMEType\0\u{2}\u{4}elapsedTime\0\u{2}\u{4}playbackRate\0\u{2}\u{5}contentIdentifier\0\u{2}\u{1e}elapsedTimeTimestamp\0\u{2}\u{6}artworkIdentifier\0")

  fileprivate class _StorageClass {
    var _title: String? = nil
    var _subtitle: String? = nil
    var _isContainer: Bool? = nil
    var _isPlayable: Bool? = nil
    var _playbackProgress: Float? = nil
    var _albumName: String? = nil
    var _trackArtistName: String? = nil
    var _albumArtistName: String? = nil
    var _duration: Double? = nil
    var _localizedContentRating: String? = nil
    var _artworkAvailable: Bool? = nil
    var _collectionIdentifier: String? = nil
    var _artworkMimetype: String? = nil
    var _elapsedTime: Double? = nil
    var _playbackRate: Float? = nil
    var _contentIdentifier: String? = nil
    var _elapsedTimeTimestamp: Double? = nil
    var _artworkIdentifier: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _subtitle = source._subtitle
      _isContainer = source._isContainer
      _isPlayable = source._isPlayable
      _playbackProgress = source._playbackProgress
      _albumName = source._albumName
      _trackArtistName = source._trackArtistName
      _albumArtistName = source._albumArtistName
      _duration = source._duration
      _localizedContentRating = source._localizedContentRating
      _artworkAvailable = source._artworkAvailable
      _collectionIdentifier = source._collectionIdentifier
      _artworkMimetype = source._artworkMimetype
      _elapsedTime = source._elapsedTime
      _playbackRate = source._playbackRate
      _contentIdentifier = source._contentIdentifier
      _elapsedTimeTimestamp = source._elapsedTimeTimestamp
      _artworkIdentifier = source._artworkIdentifier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subtitle) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isContainer) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isPlayable) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._playbackProgress) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._albumName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._trackArtistName) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._albumArtistName) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._duration) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._localizedContentRating) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._artworkAvailable) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._collectionIdentifier) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._artworkMimetype) }()
        case 35: try { try decoder.decodeSingularDoubleField(value: &_storage._elapsedTime) }()
        case 39: try { try decoder.decodeSingularFloatField(value: &_storage._playbackRate) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._contentIdentifier) }()
        case 74: try { try decoder.decodeSingularDoubleField(value: &_storage._elapsedTimeTimestamp) }()
        case 80: try { try decoder.decodeSingularStringField(value: &_storage._artworkIdentifier) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._subtitle {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._isContainer {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._isPlayable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._playbackProgress {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._albumName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._trackArtistName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._albumArtistName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._duration {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._localizedContentRating {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._artworkAvailable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._collectionIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._artworkMimetype {
        try visitor.visitSingularStringField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._elapsedTime {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._playbackRate {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._contentIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._elapsedTimeTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 74)
      } }()
      try { if let v = _storage._artworkIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 80)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MRP_ContentItemMetadata, rhs: MRP_ContentItemMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._subtitle != rhs_storage._subtitle {return false}
        if _storage._isContainer != rhs_storage._isContainer {return false}
        if _storage._isPlayable != rhs_storage._isPlayable {return false}
        if _storage._playbackProgress != rhs_storage._playbackProgress {return false}
        if _storage._albumName != rhs_storage._albumName {return false}
        if _storage._trackArtistName != rhs_storage._trackArtistName {return false}
        if _storage._albumArtistName != rhs_storage._albumArtistName {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._localizedContentRating != rhs_storage._localizedContentRating {return false}
        if _storage._artworkAvailable != rhs_storage._artworkAvailable {return false}
        if _storage._collectionIdentifier != rhs_storage._collectionIdentifier {return false}
        if _storage._artworkMimetype != rhs_storage._artworkMimetype {return false}
        if _storage._elapsedTime != rhs_storage._elapsedTime {return false}
        if _storage._playbackRate != rhs_storage._playbackRate {return false}
        if _storage._contentIdentifier != rhs_storage._contentIdentifier {return false}
        if _storage._elapsedTimeTimestamp != rhs_storage._elapsedTimeTimestamp {return false}
        if _storage._artworkIdentifier != rhs_storage._artworkIdentifier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

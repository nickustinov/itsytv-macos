// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CommandInfo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum MRP_Command: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case unknown = 0
  case play = 1
  case pause = 2
  case togglePlayPause = 3
  case stop = 4
  case nextTrack = 5
  case previousTrack = 6
  case advanceShuffleMode = 7
  case advanceRepeatMode = 8
  case beginFastForward = 9
  case endFastForward = 10
  case beginRewind = 11
  case endRewind = 12
  case rewind15Seconds = 13
  case fastForward15Seconds = 14
  case rewind30Seconds = 15
  case fastForward30Seconds = 16
  case skipForward = 18
  case skipBackward = 19
  case changePlaybackRate = 20
  case rateTrack = 21
  case likeTrack = 22
  case dislikeTrack = 23
  case bookmarkTrack = 24
  case nextChapter = 25
  case previousChapter = 26
  case nextAlbum = 27
  case previousAlbum = 28
  case nextPlaylist = 29
  case previousPlaylist = 30
  case banTrack = 31
  case addTrackToWishList = 32
  case removeTrackFromWishList = 33
  case nextInContext = 34
  case previousInContext = 35
  case resetPlaybackTimeout = 41
  case seekToPlaybackPosition = 45
  case changeRepeatMode = 46
  case changeShuffleMode = 47
  case setPlaybackQueue = 48
  case addNowPlayingItemToLibrary = 49
  case createRadioStation = 50
  case addItemToLibrary = 51
  case insertIntoPlaybackQueue = 52
  case enableLanguageOption = 53
  case disableLanguageOption = 54
  case reorderPlaybackQueue = 55
  case removeFromPlaybackQueue = 56
  case playItemInPlaybackQueue = 57
  case prepareForSetQueue = 58
  case setPlaybackSession = 59
  case preloadedPlaybackSession = 60
  case setPriorityForPlaybackSession = 61
  case discardPlaybackSession = 62
  case reshuffle = 63
  case changeQueueEndAction = 135

  init() {
    self = .unknown
  }

}

struct MRP_CommandInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: MRP_Command {
    get {return _storage._command ?? .unknown}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  var enabled: Bool {
    get {return _storage._enabled ?? false}
    set {_uniqueStorage()._enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return _storage._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {_uniqueStorage()._enabled = nil}

  var active: Bool {
    get {return _storage._active ?? false}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {_uniqueStorage()._active = nil}

  var preferredIntervals: [Double] {
    get {return _storage._preferredIntervals}
    set {_uniqueStorage()._preferredIntervals = newValue}
  }

  var localizedTitle: String {
    get {return _storage._localizedTitle ?? String()}
    set {_uniqueStorage()._localizedTitle = newValue}
  }
  /// Returns true if `localizedTitle` has been explicitly set.
  var hasLocalizedTitle: Bool {return _storage._localizedTitle != nil}
  /// Clears the value of `localizedTitle`. Subsequent reads from it will return its default value.
  mutating func clearLocalizedTitle() {_uniqueStorage()._localizedTitle = nil}

  var minimumRating: Float {
    get {return _storage._minimumRating ?? 0}
    set {_uniqueStorage()._minimumRating = newValue}
  }
  /// Returns true if `minimumRating` has been explicitly set.
  var hasMinimumRating: Bool {return _storage._minimumRating != nil}
  /// Clears the value of `minimumRating`. Subsequent reads from it will return its default value.
  mutating func clearMinimumRating() {_uniqueStorage()._minimumRating = nil}

  var maximumRating: Float {
    get {return _storage._maximumRating ?? 0}
    set {_uniqueStorage()._maximumRating = newValue}
  }
  /// Returns true if `maximumRating` has been explicitly set.
  var hasMaximumRating: Bool {return _storage._maximumRating != nil}
  /// Clears the value of `maximumRating`. Subsequent reads from it will return its default value.
  mutating func clearMaximumRating() {_uniqueStorage()._maximumRating = nil}

  var supportedRates: [Float] {
    get {return _storage._supportedRates}
    set {_uniqueStorage()._supportedRates = newValue}
  }

  var localizedShortTitle: String {
    get {return _storage._localizedShortTitle ?? String()}
    set {_uniqueStorage()._localizedShortTitle = newValue}
  }
  /// Returns true if `localizedShortTitle` has been explicitly set.
  var hasLocalizedShortTitle: Bool {return _storage._localizedShortTitle != nil}
  /// Clears the value of `localizedShortTitle`. Subsequent reads from it will return its default value.
  mutating func clearLocalizedShortTitle() {_uniqueStorage()._localizedShortTitle = nil}

  var repeatMode: MRP_RepeatMode.Enum {
    get {return _storage._repeatMode ?? .unknown}
    set {_uniqueStorage()._repeatMode = newValue}
  }
  /// Returns true if `repeatMode` has been explicitly set.
  var hasRepeatMode: Bool {return _storage._repeatMode != nil}
  /// Clears the value of `repeatMode`. Subsequent reads from it will return its default value.
  mutating func clearRepeatMode() {_uniqueStorage()._repeatMode = nil}

  var shuffleMode: MRP_ShuffleMode.Enum {
    get {return _storage._shuffleMode ?? .unknown}
    set {_uniqueStorage()._shuffleMode = newValue}
  }
  /// Returns true if `shuffleMode` has been explicitly set.
  var hasShuffleMode: Bool {return _storage._shuffleMode != nil}
  /// Clears the value of `shuffleMode`. Subsequent reads from it will return its default value.
  mutating func clearShuffleMode() {_uniqueStorage()._shuffleMode = nil}

  var presentationStyle: Int32 {
    get {return _storage._presentationStyle ?? 0}
    set {_uniqueStorage()._presentationStyle = newValue}
  }
  /// Returns true if `presentationStyle` has been explicitly set.
  var hasPresentationStyle: Bool {return _storage._presentationStyle != nil}
  /// Clears the value of `presentationStyle`. Subsequent reads from it will return its default value.
  mutating func clearPresentationStyle() {_uniqueStorage()._presentationStyle = nil}

  var skipInterval: Int32 {
    get {return _storage._skipInterval ?? 0}
    set {_uniqueStorage()._skipInterval = newValue}
  }
  /// Returns true if `skipInterval` has been explicitly set.
  var hasSkipInterval: Bool {return _storage._skipInterval != nil}
  /// Clears the value of `skipInterval`. Subsequent reads from it will return its default value.
  mutating func clearSkipInterval() {_uniqueStorage()._skipInterval = nil}

  var numAvailableSkips: Int32 {
    get {return _storage._numAvailableSkips ?? 0}
    set {_uniqueStorage()._numAvailableSkips = newValue}
  }
  /// Returns true if `numAvailableSkips` has been explicitly set.
  var hasNumAvailableSkips: Bool {return _storage._numAvailableSkips != nil}
  /// Clears the value of `numAvailableSkips`. Subsequent reads from it will return its default value.
  mutating func clearNumAvailableSkips() {_uniqueStorage()._numAvailableSkips = nil}

  var skipFrequency: Int32 {
    get {return _storage._skipFrequency ?? 0}
    set {_uniqueStorage()._skipFrequency = newValue}
  }
  /// Returns true if `skipFrequency` has been explicitly set.
  var hasSkipFrequency: Bool {return _storage._skipFrequency != nil}
  /// Clears the value of `skipFrequency`. Subsequent reads from it will return its default value.
  mutating func clearSkipFrequency() {_uniqueStorage()._skipFrequency = nil}

  var canScrub: Int32 {
    get {return _storage._canScrub ?? 0}
    set {_uniqueStorage()._canScrub = newValue}
  }
  /// Returns true if `canScrub` has been explicitly set.
  var hasCanScrub: Bool {return _storage._canScrub != nil}
  /// Clears the value of `canScrub`. Subsequent reads from it will return its default value.
  mutating func clearCanScrub() {_uniqueStorage()._canScrub = nil}

  var supportedPlaybackQueueTypes: [Int32] {
    get {return _storage._supportedPlaybackQueueTypes}
    set {_uniqueStorage()._supportedPlaybackQueueTypes = newValue}
  }

  var supportedCustomQueueIdentifiers: [String] {
    get {return _storage._supportedCustomQueueIdentifiers}
    set {_uniqueStorage()._supportedCustomQueueIdentifiers = newValue}
  }

  var supportedInsertionPositions: [Int32] {
    get {return _storage._supportedInsertionPositions}
    set {_uniqueStorage()._supportedInsertionPositions = newValue}
  }

  var supportsSharedQueue: Bool {
    get {return _storage._supportsSharedQueue ?? false}
    set {_uniqueStorage()._supportsSharedQueue = newValue}
  }
  /// Returns true if `supportsSharedQueue` has been explicitly set.
  var hasSupportsSharedQueue: Bool {return _storage._supportsSharedQueue != nil}
  /// Clears the value of `supportsSharedQueue`. Subsequent reads from it will return its default value.
  mutating func clearSupportsSharedQueue() {_uniqueStorage()._supportsSharedQueue = nil}

  var upNextItemCount: Int32 {
    get {return _storage._upNextItemCount ?? 0}
    set {_uniqueStorage()._upNextItemCount = newValue}
  }
  /// Returns true if `upNextItemCount` has been explicitly set.
  var hasUpNextItemCount: Bool {return _storage._upNextItemCount != nil}
  /// Clears the value of `upNextItemCount`. Subsequent reads from it will return its default value.
  mutating func clearUpNextItemCount() {_uniqueStorage()._upNextItemCount = nil}

  var preferredPlaybackRate: Float {
    get {return _storage._preferredPlaybackRate ?? 0}
    set {_uniqueStorage()._preferredPlaybackRate = newValue}
  }
  /// Returns true if `preferredPlaybackRate` has been explicitly set.
  var hasPreferredPlaybackRate: Bool {return _storage._preferredPlaybackRate != nil}
  /// Clears the value of `preferredPlaybackRate`. Subsequent reads from it will return its default value.
  mutating func clearPreferredPlaybackRate() {_uniqueStorage()._preferredPlaybackRate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MRP_Command: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Unknown\0\u{1}Play\0\u{1}Pause\0\u{1}TogglePlayPause\0\u{1}Stop\0\u{1}NextTrack\0\u{1}PreviousTrack\0\u{1}AdvanceShuffleMode\0\u{1}AdvanceRepeatMode\0\u{1}BeginFastForward\0\u{1}EndFastForward\0\u{1}BeginRewind\0\u{1}EndRewind\0\u{1}Rewind15Seconds\0\u{1}FastForward15Seconds\0\u{1}Rewind30Seconds\0\u{1}FastForward30Seconds\0\u{2}\u{2}SkipForward\0\u{1}SkipBackward\0\u{1}ChangePlaybackRate\0\u{1}RateTrack\0\u{1}LikeTrack\0\u{1}DislikeTrack\0\u{1}BookmarkTrack\0\u{1}NextChapter\0\u{1}PreviousChapter\0\u{1}NextAlbum\0\u{1}PreviousAlbum\0\u{1}NextPlaylist\0\u{1}PreviousPlaylist\0\u{1}BanTrack\0\u{1}AddTrackToWishList\0\u{1}RemoveTrackFromWishList\0\u{1}NextInContext\0\u{1}PreviousInContext\0\u{2}\u{6}ResetPlaybackTimeout\0\u{2}\u{4}SeekToPlaybackPosition\0\u{1}ChangeRepeatMode\0\u{1}ChangeShuffleMode\0\u{1}SetPlaybackQueue\0\u{1}AddNowPlayingItemToLibrary\0\u{1}CreateRadioStation\0\u{1}AddItemToLibrary\0\u{1}InsertIntoPlaybackQueue\0\u{1}EnableLanguageOption\0\u{1}DisableLanguageOption\0\u{1}ReorderPlaybackQueue\0\u{1}RemoveFromPlaybackQueue\0\u{1}PlayItemInPlaybackQueue\0\u{1}PrepareForSetQueue\0\u{1}SetPlaybackSession\0\u{1}PreloadedPlaybackSession\0\u{1}SetPriorityForPlaybackSession\0\u{1}DiscardPlaybackSession\0\u{1}Reshuffle\0\u{2}H\u{1}ChangeQueueEndAction\0")
}

extension MRP_CommandInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CommandInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}enabled\0\u{1}active\0\u{1}preferredIntervals\0\u{1}localizedTitle\0\u{1}minimumRating\0\u{1}maximumRating\0\u{1}supportedRates\0\u{1}localizedShortTitle\0\u{1}repeatMode\0\u{1}shuffleMode\0\u{1}presentationStyle\0\u{1}skipInterval\0\u{1}numAvailableSkips\0\u{1}skipFrequency\0\u{1}canScrub\0\u{1}supportedPlaybackQueueTypes\0\u{1}supportedCustomQueueIdentifiers\0\u{1}supportedInsertionPositions\0\u{1}supportsSharedQueue\0\u{1}upNextItemCount\0\u{1}preferredPlaybackRate\0")

  fileprivate class _StorageClass {
    var _command: MRP_Command? = nil
    var _enabled: Bool? = nil
    var _active: Bool? = nil
    var _preferredIntervals: [Double] = []
    var _localizedTitle: String? = nil
    var _minimumRating: Float? = nil
    var _maximumRating: Float? = nil
    var _supportedRates: [Float] = []
    var _localizedShortTitle: String? = nil
    var _repeatMode: MRP_RepeatMode.Enum? = nil
    var _shuffleMode: MRP_ShuffleMode.Enum? = nil
    var _presentationStyle: Int32? = nil
    var _skipInterval: Int32? = nil
    var _numAvailableSkips: Int32? = nil
    var _skipFrequency: Int32? = nil
    var _canScrub: Int32? = nil
    var _supportedPlaybackQueueTypes: [Int32] = []
    var _supportedCustomQueueIdentifiers: [String] = []
    var _supportedInsertionPositions: [Int32] = []
    var _supportsSharedQueue: Bool? = nil
    var _upNextItemCount: Int32? = nil
    var _preferredPlaybackRate: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _command = source._command
      _enabled = source._enabled
      _active = source._active
      _preferredIntervals = source._preferredIntervals
      _localizedTitle = source._localizedTitle
      _minimumRating = source._minimumRating
      _maximumRating = source._maximumRating
      _supportedRates = source._supportedRates
      _localizedShortTitle = source._localizedShortTitle
      _repeatMode = source._repeatMode
      _shuffleMode = source._shuffleMode
      _presentationStyle = source._presentationStyle
      _skipInterval = source._skipInterval
      _numAvailableSkips = source._numAvailableSkips
      _skipFrequency = source._skipFrequency
      _canScrub = source._canScrub
      _supportedPlaybackQueueTypes = source._supportedPlaybackQueueTypes
      _supportedCustomQueueIdentifiers = source._supportedCustomQueueIdentifiers
      _supportedInsertionPositions = source._supportedInsertionPositions
      _supportsSharedQueue = source._supportsSharedQueue
      _upNextItemCount = source._upNextItemCount
      _preferredPlaybackRate = source._preferredPlaybackRate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._command) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._enabled) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._active) }()
        case 4: try { try decoder.decodeRepeatedDoubleField(value: &_storage._preferredIntervals) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._localizedTitle) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._minimumRating) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._maximumRating) }()
        case 8: try { try decoder.decodeRepeatedFloatField(value: &_storage._supportedRates) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._localizedShortTitle) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._repeatMode) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._shuffleMode) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._presentationStyle) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._skipInterval) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._numAvailableSkips) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._skipFrequency) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._canScrub) }()
        case 17: try { try decoder.decodeRepeatedInt32Field(value: &_storage._supportedPlaybackQueueTypes) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedCustomQueueIdentifiers) }()
        case 19: try { try decoder.decodeRepeatedInt32Field(value: &_storage._supportedInsertionPositions) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._supportsSharedQueue) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._upNextItemCount) }()
        case 22: try { try decoder.decodeSingularFloatField(value: &_storage._preferredPlaybackRate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._command {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._enabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._active {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      if !_storage._preferredIntervals.isEmpty {
        try visitor.visitRepeatedDoubleField(value: _storage._preferredIntervals, fieldNumber: 4)
      }
      try { if let v = _storage._localizedTitle {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._minimumRating {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._maximumRating {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      if !_storage._supportedRates.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._supportedRates, fieldNumber: 8)
      }
      try { if let v = _storage._localizedShortTitle {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._repeatMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._shuffleMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._presentationStyle {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._skipInterval {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._numAvailableSkips {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._skipFrequency {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._canScrub {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      } }()
      if !_storage._supportedPlaybackQueueTypes.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._supportedPlaybackQueueTypes, fieldNumber: 17)
      }
      if !_storage._supportedCustomQueueIdentifiers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedCustomQueueIdentifiers, fieldNumber: 18)
      }
      if !_storage._supportedInsertionPositions.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._supportedInsertionPositions, fieldNumber: 19)
      }
      try { if let v = _storage._supportsSharedQueue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._upNextItemCount {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._preferredPlaybackRate {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MRP_CommandInfo, rhs: MRP_CommandInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._command != rhs_storage._command {return false}
        if _storage._enabled != rhs_storage._enabled {return false}
        if _storage._active != rhs_storage._active {return false}
        if _storage._preferredIntervals != rhs_storage._preferredIntervals {return false}
        if _storage._localizedTitle != rhs_storage._localizedTitle {return false}
        if _storage._minimumRating != rhs_storage._minimumRating {return false}
        if _storage._maximumRating != rhs_storage._maximumRating {return false}
        if _storage._supportedRates != rhs_storage._supportedRates {return false}
        if _storage._localizedShortTitle != rhs_storage._localizedShortTitle {return false}
        if _storage._repeatMode != rhs_storage._repeatMode {return false}
        if _storage._shuffleMode != rhs_storage._shuffleMode {return false}
        if _storage._presentationStyle != rhs_storage._presentationStyle {return false}
        if _storage._skipInterval != rhs_storage._skipInterval {return false}
        if _storage._numAvailableSkips != rhs_storage._numAvailableSkips {return false}
        if _storage._skipFrequency != rhs_storage._skipFrequency {return false}
        if _storage._canScrub != rhs_storage._canScrub {return false}
        if _storage._supportedPlaybackQueueTypes != rhs_storage._supportedPlaybackQueueTypes {return false}
        if _storage._supportedCustomQueueIdentifiers != rhs_storage._supportedCustomQueueIdentifiers {return false}
        if _storage._supportedInsertionPositions != rhs_storage._supportedInsertionPositions {return false}
        if _storage._supportsSharedQueue != rhs_storage._supportsSharedQueue {return false}
        if _storage._upNextItemCount != rhs_storage._upNextItemCount {return false}
        if _storage._preferredPlaybackRate != rhs_storage._preferredPlaybackRate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
